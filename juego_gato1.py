# -*- coding: utf-8 -*-
"""juego-gato1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rm1W3QjKlxNU3Ill7c6aiFPSBpXW2SD5
"""

import random
def crear_tablero():
    tablero = [[" ", " ", " "],[" ", " ", " "],[" ", " ", " "]]
    return tablero

def imprimir_tablero(tablero):
    print(f"{tablero[0][0]}|{tablero[0][1]}|{tablero[0][2]}")
    print("-----")
    print(f"{tablero[1][0]}|{tablero[1][1]}|{tablero[1][2]}")
    print("-----")
    print(f"{tablero[2][0]}|{tablero[2][1]}|{tablero[2][2]}")

def movimiento_jugador(tablero, jugador):
    while True:
        try:
            fila = int(input("Elige fila (0, 1, 2): "))
            columna = int(input("Elige columna (0, 1, 2): "))
            if 0 <= fila < 3 and 0 <= columna < 3:
                if tablero[fila][columna] == " ":
                    tablero[fila][columna] = jugador
                    break
                else:
                    print("¡Casilla ocupada!")
            else:
                print("¡Entrada inválida! Las filas y columnas deben estar entre 0 y 2.")
        except ValueError:
            print("¡Entrada inválida! Por favor, introduce números.")


def hay_ganador(tablero):
    # Verificar filas y columnas
    for i in range(3):
        if tablero[i][0] == tablero[i][1] == tablero[i][2] != " ":
            return True
        if tablero[0][i] == tablero[1][i] == tablero[2][i] != " ":
            return True

    # Verificar diagonales
    if tablero[0][0] == tablero[1][1] == tablero[2][2] != " ":
        return True
    if tablero[0][2] == tablero[1][1] == tablero[2][0] != " ":
        return True

    return False


def tablero_lleno(tablero):
    for fila in tablero:
        if " " in fila:
            return False
    return True


def movimiento_ia(tablero):
    # Check if AI can win in the next move
    for i in range(3):
        for j in range(3):
            if tablero[i][j] == " ":
                tablero[i][j] = "O"
                if hay_ganador(tablero):
                    return
                tablero[i][j] = " " # Undo the move

    # Check if player can win in the next move and block them
    for i in range(3):
        for j in range(3):
            if tablero[i][j] == " ":
                tablero[i][j] = "X" # Temporarily place player's move
                if hay_ganador(tablero):
                    tablero[i][j] = "O" # Block the player
                    return
                tablero[i][j] = " " # Undo the player's temporary move


    # If no winning or blocking move, make a random move
    casillas_vacias = [(i, j) for i in range(3) for j in range(3) if tablero[i][j] == " "]
    if casillas_vacias:
        fila, columna = random.choice(casillas_vacias)
        tablero[fila][columna] = "O"


def juego_completo():
    victorias_x = 0
    victorias_o = 0

    while True:
        tablero = crear_tablero()
        jugador_actual = "X"

        while True:
            imprimir_tablero(tablero)
            print(f"Turno de {jugador_actual}")

            if jugador_actual == "X":
                movimiento_jugador(tablero, jugador_actual)
            else:
                movimiento_ia(tablero)


            if hay_ganador(tablero):
                imprimir_tablero(tablero)
                print(f"¡{jugador_actual} ha ganado!")
                if jugador_actual == "X":
                    victorias_x += 1
                else:
                    victorias_o += 1
                break

            if tablero_lleno(tablero):
                imprimir_tablero(tablero)
                print("¡Empate!")
                break

            if(jugador_actual=="O"):
                jugador_actual="X"
            else:
                jugador_actual = "O"

        print(f"Puntuación: Jugador X - {victorias_x}, Jugador O - {victorias_o}")

        jugar_de_nuevo = input("¿Quieres jugar de nuevo? (s/n): ").lower()
        if jugar_de_nuevo != 's':
            break


juego_completo()

"""# Task
Refactor the provided Python code for a Tic-Tac-Toe game. The refactoring should include: 1. Eliminating unnecessary or duplicate functions. 2. Ensuring the game correctly detects ties using the `tablero_lleno` function. 3. Adding functionality to track and display the number of games won by each player (e.g., using `victorias_x` and `victorias_y` variables). 4. Improving the AI's move selection logic in the `movimiento_ia` function to be more strategic (e.g., prioritize winning moves and blocking player winning moves).

## Analyze current ai

### Subtask:
Review the existing `movimiento_ia` function to understand its current logic (random move selection).

**Reasoning**:
The subtask is to understand the current logic of the `movimiento_ia` function. By examining the code and describing its functionality, I can fulfill this requirement.
"""